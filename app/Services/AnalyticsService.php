<?php

namespace App\Services;

use App\Models\PosSale;
use App\Models\Inventory;
use App\Models\Staff;
use App\Models\Expense;
use Carbon\Carbon;
use Illuminate\Support\Facades\DB;

class AnalyticsService
{
    /**
     * Get comprehensive staff performance metrics
     */
    public function getStaffPerformance(Carbon $startDate, Carbon $endDate)
    {
        // 1. Aggregated Sales by Seller
        $staffMetrics = PosSale::whereBetween('created_at', [$startDate, $endDate])
            ->select(
                'seller_username',
                DB::raw('COUNT(*) as transaction_count'),
                DB::raw('SUM(total) as total_revenue'),
                DB::raw('AVG(total) as average_ticket_value')
            )
            ->groupBy('seller_username')
            ->get();

        // 2. Enhance with Commission Data (if available) & Profitability
        return $staffMetrics->map(function ($metric) use ($startDate, $endDate) {
            // Calculate gross profit generated by this staff member
            // We need to fetch the actual sales to iterate items for cost calculation
            // This is resource intensive, so we do it per staff
            $sales = PosSale::where('seller_username', $metric->seller_username)
                ->whereBetween('created_at', [$startDate, $endDate])
                ->get();
            
            $totalCost = 0;
            $itemsSold = 0;

            foreach ($sales as $sale) {
                if (isset($sale->sale_items) && is_array($sale->sale_items)) {
                    foreach ($sale->sale_items as $item) {
                        // Assuming 'quantity' and 'buying_price' (or cost) exist in snapshot
                        // If buying_price isn't in snapshot, we might need to look up current inventory cost (less accurate for historical)
                        // Fallback: use product_snapshot.buying_price if available, else 0
                        
                        $qty = $item['quantity'] ?? 0;
                        // Snapshot might contain 'buying_price', 'cost_price', or 'price' depending on how it was saved
                        $cost = $item['product_snapshot']['buying_price'] 
                             ?? $item['product_snapshot']['cost_price'] 
                             ?? $item['product_snapshot']['price'] 
                             ?? 0;
                        
                        if ($cost == 0 && isset($item['product_id'])) {
                             // Fallback to current master cost
                             $product = Inventory::find($item['product_id']);
                             // Assuming 'price' in Inventory is the cost price based on profit calc
                             $cost = $product ? $product->price : 0;
                        }

                        $totalCost += ($cost * $qty);
                        $itemsSold += $qty;
                    }
                }
            }

            $grossProfit = $metric->total_revenue - $totalCost;
            $margin = $metric->total_revenue > 0 ? ($grossProfit / $metric->total_revenue) * 100 : 0;

            return [
                'name' => $metric->seller_username, // Map to real name if needed via Staff model
                'transactions' => $metric->transaction_count,
                'revenue' => $metric->total_revenue,
                'avg_ticket' => $metric->average_ticket_value,
                'gross_profit' => $grossProfit,
                'margin_percent' => round($margin, 2),
                'items_sold' => $itemsSold
            ];
        })->sortByDesc('revenue')->values();
    }

    /**
     * Get Product Profitability Analysis
     */
    public function getProductProfitability(Carbon $startDate, Carbon $endDate, $limit = 20)
    {
        // We need to iterate all sales items. 
        // For performance on large datasets, this should ideally be an SQL View or dedicated stats table.
        // For now, we process in PHP with chunking if needed, or focused query.

        $sales = PosSale::whereBetween('created_at', [$startDate, $endDate])->get();
        
        $productStats = [];

        foreach ($sales as $sale) {
            if (!isset($sale->sale_items) || !is_array($sale->sale_items)) continue;

            foreach ($sale->sale_items as $item) {
                $name = $item['product_name'] ?? 'Unknown';
                $id = $item['product_id'] ?? 'diff_' . $name; // Unique key
                $qty = $item['quantity'] ?? 0;
                $price = $item['unit_price'] ?? 0;
                $total = $item['item_total'] ?? 0;
                
                // reliable cost finding
                $cost = 0;
                if (isset($item['product_snapshot']['buying_price'])) {
                    $cost = $item['product_snapshot']['buying_price'];
                } elseif (isset($item['product_snapshot']['price'])) {
                    $cost = $item['product_snapshot']['price'];
                } else {
                     // Try to find in current inventory as fallback
                     if (isset($item['product_id'])) {
                         $inv = Inventory::find($item['product_id']);
                         if ($inv) $cost = $inv->price;
                     }
                }

                $profit = $total - ($cost * $qty);

                if (!isset($productStats[$id])) {
                    $productStats[$id] = [
                        'id' => $id,
                        'name' => $name,
                        'qty_sold' => 0,
                        'total_revenue' => 0,
                        'total_cost' => 0,
                        'total_profit' => 0,
                    ];
                }

                $productStats[$id]['qty_sold'] += $qty;
                $productStats[$id]['total_revenue'] += $total;
                $productStats[$id]['total_cost'] += ($cost * $qty);
                $productStats[$id]['total_profit'] += $profit;
            }
        }

        // Calculate margins and format
        $results = collect($productStats)->map(function($stat) {
            $margin = $stat['total_revenue'] > 0 
                ? ($stat['total_profit'] / $stat['total_revenue']) * 100 
                : 0;

            return [
                'name' => $stat['name'],
                'qty' => $stat['qty_sold'],
                'revenue' => $stat['total_revenue'],
                'profit' => $stat['total_profit'],
                'margin' => round($margin, 2)
            ];
        });

        return [
            'by_profit' => $results->sortByDesc('profit')->take($limit)->values(),
            'by_volume' => $results->sortByDesc('qty')->take($limit)->values(),
            'high_margin' => $results->where('qty', '>', 5)->sortByDesc('margin')->take($limit)->values(), // Min 5 sold to avoid outliers
        ];
    }

    /**
     * Get Weekly/Monthly Trends
     */
    public function getTrends(Carbon $startDate, Carbon $endDate)
    {
        $sales = PosSale::whereBetween('created_at', [$startDate, $endDate])
            ->select(
                DB::raw('DATE(created_at) as date'),
                DB::raw('SUM(total) as revenue'),
                DB::raw('COUNT(*) as count')
            )
            ->groupBy('date')
            ->orderBy('date')
            ->get();

        return $sales;
    }

    /**
     * Get Customer Insights
     */
    public function getCustomerInsights(Carbon $startDate, Carbon $endDate, $limit = 10)
    {
        return PosSale::whereBetween('created_at', [$startDate, $endDate])
            ->whereNotNull('customer_id') 
            ->select(
                'customer_name',
                DB::raw('COUNT(*) as transaction_count'),
                DB::raw('SUM(total) as total_spent'),
                DB::raw('MAX(created_at) as last_purchase')
            )
            ->groupBy('customer_name')
            ->orderByDesc('total_spent')
            ->limit($limit)
            ->get();
    }

    /**
     * Get Peak Sales Times (Hour of Day)
     */
    public function getPeakSalesTimes(Carbon $startDate, Carbon $endDate)
    {
        // SQLite uses strftime('%H', ...), MySQL uses HOUR(...)
        // Assuming MySQL given 'laravel-version'. If SQLite, use strftime.
        // We will try generic approach or check driver, but typical LAMP stack is MySQL.
        // Let's use a safe fallback for SQLite if needed, but typically:
        
        $driver = DB::connection()->getDriverName();
        $hourFunc = $driver === 'sqlite' ? "strftime('%H', created_at)" : 'HOUR(created_at)';

        return PosSale::whereBetween('created_at', [$startDate, $endDate])
            ->select(
                DB::raw("$hourFunc as hour"),
                DB::raw('COUNT(*) as count'),
                DB::raw('SUM(total) as revenue')
            )
            ->groupBy('hour')
            ->orderBy('hour')
            ->get();
    }

    /**
     * Get Payment Method Trends
     */
    public function getPaymentTrends(Carbon $startDate, Carbon $endDate)
    {
        return PosSale::whereBetween('created_at', [$startDate, $endDate])
            ->select(
                'payment_method',
                DB::raw('COUNT(*) as count'),
                DB::raw('SUM(total) as total')
            )
            ->groupBy('payment_method')
            ->orderByDesc('total')
            ->get();
    }
}
